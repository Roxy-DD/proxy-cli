# 使用 Rust 构建现代化的 PowerShell 代理管理工具：技术深度解析

在日常开发中，我们经常需要为终端设置代理。虽然可以通过 `set HTTP_PROXY=...` 手动设置，但这很繁琐且容易忘记关闭。

本文将分享我如何使用 **Rust** 构建一个轻量级、交互式且**零依赖**的 PowerShell 代理管理工具 (`proxy-cli`)。我们将深入探讨其背后的架构设计、使用的关键库以及遇到的技术挑战。

## 1. 核心架构：Wrapper Pattern (包装器模式)

开发这个工具时遇到的最大挑战是操作系统的基本限制：**子进程无法修改父进程的环境变量**。

当我们运行一个 Rust 程序时，它是一个独立的子进程。它修改的 `env::set_var` 仅对自己有效，程序退出后，父进程（PowerShell）的环境变量完全不会改变。

为了解决这个问题，我采用了 **Wrapper Pattern**：

1.  **Rust (UI 层)**：负责与用户交互、管理配置。
    -   当用户决定开启代理时，Rust 程序**不直接设置环境变量**。
    -   而是将指令打印到标准输出 (`stdout`)，例如：`#SET_PROXY:http://127.0.0.1:7890`。
    -   所有 UI 绘制都通过标准错误 (`stderr`) 进行，互不干扰。

2.  **PowerShell (执行层)**：
    -   我们定义了一个 `proxy` 函数包裹 Rust 程序。
    -   它捕获 Rust 程序的 `stdout`。
    -   一旦匹配到 `#SET_PROXY` 指令，就在**当前 Shell 上下文**中执行 `$env:HTTP_PROXY = ...`。

这种设计完美结合了 Rust 的高性能 TUI 能力和 Shell 脚本的环境控制能力。

## 2. 技术栈选型

为了打造极致的用户体验，我精选了以下 Rust Crates：

### 交互体验 (TUI)
*   **`dialoguer`**: 这是工具的"脸面"。它提供了开箱即用的 Select（选择菜单）和 Input（输入框）组件。
    *   *技巧*：它内置了防抖和按需刷新机制，彻底解决了手写 TUI 常见的闪烁问题。
*   **`console`**: `dialoguer` 的底层依赖。用于处理跨平台的终端操作（如清屏、光标移动、颜色输出）。

### 配置管理
*   **`serde` & `serde_json`**: Rust 界的序列化标准。用于将用户的配置（端口、启用状态）保存为 JSON 文件。
*   **`directories`**: 一个非常实用的小库，用于获取符合操作系统标准的配置目录（如 Windows 的 `%APPDATA%`），确保工具的行为符合系统规范。

## 3. 关键技术点与挑战

### 3.1 解决 TUI 闪烁与输入抖动
很多 CLI 工具在刷新界面时会有明显的闪烁。我的解决方案是：
*   **阻塞式交互**：主循环使用 `match main_menu()` 阻塞等待用户输入。只有用户按键后才重绘，静止时不消耗任何资源。
*   **双缓冲思想**：`dialoguer` 内部只重绘变化的部分，而不是暴力清空整个屏幕。
*   **流分离**：UI 渲染走 `stderr`，指令输出走 `stdout`。这避免了输出缓冲导致的界面撕裂。

### 3.2 自安装机制 (Self-Installation)
为了让用户"双击即用"，我实现了一个自安装逻辑：
*   程序启动时检测 `env::current_exe()` 获取自身路径。
*   扫描标准 PowerShell 配置文件路径（`$PROFILE`）。
*   如果发现未安装，直接将 Wrapper 函数代码（包含硬编码的 exe 路径）追加写入到 `$PROFILE` 中。
*   利用 Rust 的 `r##"..."##` 原始字符串语法，轻松处理包含大量引号和特殊字符的 PowerShell 脚本模板。

## 4. 总结

通过 Rust，我们不仅获得了一个 2MB 大小的独立二进制文件（无需 Python/Node 环境），还拥有了类型安全和极高的执行效率。

这个项目展示了系统编程的一个重要思路：**不要试图对抗操作系统的限制，而是用架构去适应它**。通过简单的 Wrapper Pattern，我们打破了进程间的隔离，实现了优雅的环境变量管理。

---
*项目已开源，欢迎 Star 和贡献代码！*
